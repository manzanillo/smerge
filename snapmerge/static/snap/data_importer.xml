<project name="data_importer" app="Snap! 9.0, https://snap.berkeley.edu" version="2">
    <notes></notes>
    <thumbnail>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAB4CAYAAAB1ovlvAAACqElEQVR4Xu3XMY7aUABF0e99QA/LAYkN0bAgEKuBjUBBRqSYYmaSKIWvZB3Xlp58/xHG0+vjGi4FogITgFF5s+8CAIKQFgAwzW8cQAbSAgCm+Y0DyEBaAMA0v3EAGUgLAJjmNw4gA2kBANP8xgFkIC0AYJrfOIAMpAUATPMbB5CBtACAaX7jADKQFgAwzW8cQAbSAgCm+Y0DyEBaAMA0v3EAGUgLAJjmNw4gA2kBANP8xgFkIC0AYJrfOIAMpAUATPMbB5CBtACAaX7jADKQFgAwzW8cQAbSAgCm+Y0DyEBaAMA0v3EAGUgLAJjmNw4gA2kBANP8xgFkIC0AYJrfOIAMpAUATPMbB5CBtACAaX7jADKQFgAwzW8cQAbSAgCm+Y0DyEBaAMA0v3EAGUgLAPhD/u12O47H4zgcDukBLX0cwD+c8H6/H6/X633H7XYb1+t1rNfrpZuY9fkA/Evu3W735Y5pmsbz+Rzn83nWw1riGID/CfDxeIzL5bJEE7M+E4D/+Aq+3+/vV/BqtZr1gJY+BuAPJ7zZbMbpdBrfvYKXjmLO5wNwztq2vv6f/vjK+/2Z51IgKOAXMIhu8rMAgDSkBQBM8xsHkIG0AIBpfuMAMpAWADDNbxxABtICAKb5jQPIQFoAwDS/cQAZSAsAmOY3DiADaQEA0/zGAWQgLQBgmt84gAykBQBM8xsHkIG0AIBpfuMAMpAWADDNbxxABtICAKb5jQPIQFoAwDS/cQAZSAsAmOY3DiADaQEA0/zGAWQgLQBgmt84gAykBQBM8xsHkIG0AIBpfuMAMpAWADDNbxxABtICAKb5jQPIQFoAwDS/cQAZSAsAmOY3DiADaQEA0/zGAWQgLQBgmt84gAykBQBM8xsHkIG0AIBpfuMAMpAWADDNb/wXK14Ct+2fpIIAAAAASUVORK5CYII=</thumbnail>
    <scenes select="1">
        <scene name="data_importer">
            <notes></notes>
            <hidden> forward turn turnLeft setHeading doFaceTowards gotoXY doGotoObject doGlide changeXPosition setXPosition changeYPosition setYPosition bounceOffEdge getPosition xPosition yPosition direction doSwitchToCostume doWearNextCostume getCostumeIdx doSayFor bubble doThinkFor doThink reportGetImageAttribute reportNewCostumeStretched reportNewCostume changeEffect setEffect clearEffects getEffect changeScale setScale getScale show hide reportShown goToLayer goBack playSound doPlaySoundUntilDone doStopAllSounds doPlaySoundAtRate reportGetSoundAttribute reportNewSoundFromSamples doRest doPlayNote doSetInstrument doChangeTempo doSetTempo getTempo changeVolume setVolume getVolume changePan setPan getPan playFreq stopFreq clear down up getPenDown setColor changePenColorDimension setPenColorDimension getPenAttribute changeSize setSize doStamp floodFill write reportPenTrailsAsCostume doPasteOn doCutFrom receiveGo receiveKey receiveInteraction receiveCondition receiveMessage doBroadcast doBroadcastAndWait doWarp doWait doWaitUntil doForever doRepeat doUntil doFor doIf doIfElse reportIfElse doReport doStopThis doRun fork evaluate reportPipe doTellTo reportAskFor receiveOnClone createClone newClone removeClone doPauseAll doSwitchToScene receiveUserEdit doDefineBlock doDeleteBlock doSetBlockAttribute reportBlockAttribute reportEnvironment reportTouchingObject reportTouchingColor reportColorIsTouchingColor doAsk getLastAnswer reportMousePosition reportMouseX reportMouseY reportMouseDown reportKeyPressed reportRelationTo reportAspect doResetTimer getTimer reportDate reportAttributeOf reportGet reportObject reportURL reportAudio reportVideo doSetVideoTransparency reportGlobalFlag doSetGlobalFlag reifyScript reifyReporter reifyPredicate reportVariadicSum reportDifference reportVariadicProduct reportQuotient reportPower reportModulus reportVariadicMin reportVariadicMax reportRound reportMonadic reportAtan2 reportRandom reportVariadicLessThan reportVariadicEquals reportVariadicGreaterThan reportVariadicAnd reportVariadicOr reportNot reportBoolean reportJoinWords reportTextSplit reportLetter reportTextAttribute reportUnicode reportUnicodeAsLetter reportIsA reportVariadicIsIdentical doSetVar doChangeVar doShowVar doHideVar doDeclareVariables doDeleteAttr reportNewList reportNumbers reportCONS reportListItem reportCDR reportListAttribute reportListIndex reportListContainsItem reportListIsEmpty reportMap reportKeep reportFindFirst reportCombine doForEach doAddToList doDeleteFromList doInsertInList doReplaceInList reportConcatenatedLists reportReshape reportCrossproduct setBackgroundColor changeBackgroundColorDimension setBackgroundColorDimension</hidden>
            <headers></headers>
            <code></code>
            <blocks>
                <block-definition s="Activate JS and Import Data" type="command" category="other">
                    <header></header>
                    <code></code>
                    <translations></translations>
                    <inputs></inputs>
                    <script>
                        <block s="doRun">
                            <block s="reportJSFunction">
                                <list></list>
                                <l>SnapSerializer.prototype.loadScripts = function (object, scripts, model) {&#xD;    // private&#xD;    var scale = SyntaxElementMorph.prototype.scale;&#xD;    scripts.cachedTexture = IDE_Morph.prototype.scriptsPaneTexture;&#xD;    model.children.forEach(child =&gt; {&#xD;        var element;&#xD;        if (child.tag === 'script') {&#xD;            element = this.loadScript(child, object);&#xD;            if (!element) {&#xD;                return;&#xD;            }&#xD;&#xD;            if(child.attributes["customData"]){&#xD;                element.customData = child.attributes["customData"];&#xD;            }&#xD;&#xD;            element.setPosition(new Point(&#xD;                (+child.attributes.x || 0) * scale,&#xD;                (+child.attributes.y || 0) * scale&#xD;            ).add(scripts.topLeft()));&#xD;            scripts.add(element);&#xD;            element.fixBlockColor(null, true); // force zebra coloring&#xD;            element.allComments().forEach(comment =&gt; comment.align(element));&#xD;        } else if (child.tag === 'comment') {&#xD;            element = this.loadComment(child);&#xD;            if (!element) {&#xD;                return;&#xD;            }&#xD;&#xD;            if(child.attributes["customData"]){&#xD;                element.customData = child.attributes["customData"];&#xD;            }&#xD;&#xD;            element.setPosition(new Point(&#xD;                (+child.attributes.x || 0) * scale,&#xD;                (+child.attributes.y || 0) * scale&#xD;            ).add(scripts.topLeft()));&#xD;            scripts.add(element);&#xD;        }&#xD;    });&#xD;};&#xD;&#xD;SnapSerializer.prototype.loadScriptsArray = function (model, object) {&#xD;    // private - answer an array containting the model's scripts&#xD;    var scale = SyntaxElementMorph.prototype.scale,&#xD;        scripts = [];&#xD;    model.children.forEach(child =&gt; {&#xD;        var element;&#xD;        if (child.tag === 'script') {&#xD;            element = this.loadScript(child, object);&#xD;            if (!element) {&#xD;                return;&#xD;            }&#xD;&#xD;            if(child.attributes["customData"]){&#xD;                element.customData = child.attributes["customData"];&#xD;            }&#xD;&#xD;            element.setPosition(new Point(&#xD;                (+child.attributes.x || 0) * scale,&#xD;                (+child.attributes.y || 0) * scale&#xD;            ));&#xD;            scripts.push(element);&#xD;            element.fixBlockColor(null, true); // force zebra coloring&#xD;        } else if (child.tag === 'comment') {&#xD;            element = this.loadComment(child);&#xD;            if (!element) {&#xD;                return;&#xD;            }&#xD;&#xD;            if(child.attributes["customData"]){&#xD;                element.customData = child.attributes["customData"];&#xD;            }&#xD;&#xD;            element.setPosition(new Point(&#xD;                (+child.attributes.x || 0) * scale,&#xD;                (+child.attributes.y || 0) * scale&#xD;            ));&#xD;            scripts.push(element);&#xD;        }&#xD;    });&#xD;    return scripts;&#xD;};&#xD;&#xD;BlockMorph.prototype.toXML = BlockMorph.prototype.toScriptXML = function (&#xD;    serializer,&#xD;    savePosition&#xD;) {&#xD;    var position,&#xD;        xml,&#xD;        scale = SyntaxElementMorph.prototype.scale,&#xD;        block = this;&#xD;    // determine my position&#xD;    if (this.parent) {&#xD;        position = this.topLeft().subtract(this.parent.topLeft());&#xD;    } else {&#xD;        position = this.topLeft();&#xD;    }&#xD;&#xD;    // save my position to xml&#xD;    if (savePosition) {&#xD;        xml = serializer.format(&#xD;            '&lt;script x="@" y="@"&gt;',&#xD;            position.x / scale,&#xD;            position.y / scale&#xD;        );&#xD;        if (block.customData) {&#xD;            xml = serializer.format(&#xD;                '&lt;script x="@" y="@" customData="@"&gt;',&#xD;                position.x / scale,&#xD;                position.y / scale,&#xD;                block.customData&#xD;            );&#xD;        } else {&#xD;            xml = serializer.format(&#xD;                '&lt;script x="@" y="@"&gt;',&#xD;                position.x / scale,&#xD;                position.y / scale&#xD;            );&#xD;        }&#xD;    } else {&#xD;        xml = '&lt;script&gt;';&#xD;    }&#xD;    // recursively add my next blocks to xml&#xD;    do {&#xD;        xml += block.toBlockXML(serializer);&#xD;        block = block.nextBlock();&#xD;    } while (block);&#xD;    xml += '&lt;/script&gt;';&#xD;    return xml;&#xD;};&#xD;&#xD;&#xD;ReporterBlockMorph.prototype.toScriptXML = function (&#xD;    serializer,&#xD;    savePosition&#xD;) {&#xD;    var position,&#xD;        scale = SyntaxElementMorph.prototype.scale;&#xD;    // determine my save-position&#xD;    if (this.parent) {&#xD;        position = this.topLeft().subtract(this.parent.topLeft());&#xD;    } else {&#xD;        position = this.topLeft();&#xD;    }&#xD;&#xD;    if (savePosition) {&#xD;        if (this.customData) {&#xD;            return serializer.format(&#xD;                '&lt;script x="@" y="@" customData="@"&gt;%&lt;/script&gt;',&#xD;                position.x / scale,&#xD;                position.y / scale,&#xD;                this.customData,&#xD;                this.toXML(serializer)&#xD;            );&#xD;        }&#xD;&#xD;        return serializer.format(&#xD;            '&lt;script x="@" y="@"&gt;%&lt;/script&gt;',&#xD;            position.x / scale,&#xD;            position.y / scale,&#xD;            this.toXML(serializer)&#xD;        );&#xD;    }&#xD;    return serializer.format('&lt;script&gt;%&lt;/script&gt;', this.toXML(serializer));&#xD;};&#xD;&#xD;CommentMorph.prototype.toXML = function (serializer) {&#xD;    var position,&#xD;        scale = SyntaxElementMorph.prototype.scale;&#xD;    if (this.block) { // attached to a block&#xD;        return serializer.format(&#xD;            '&lt;comment w="@" collapsed="@"&gt;%&lt;/comment&gt;',&#xD;            this.textWidth() / scale,&#xD;            this.isCollapsed,&#xD;            serializer.escape(this.text())&#xD;        );&#xD;    }&#xD;    // free-floating, determine my save-position&#xD;    if (this.parent) {&#xD;        position = this.topLeft().subtract(this.parent.topLeft());&#xD;    } else {&#xD;        position = this.topLeft();&#xD;    }&#xD;&#xD;    if (this.customData) {&#xD;        return serializer.format(&#xD;            '&lt;comment x="@" y="@" w="@" collapsed="@" customData="@"&gt;%&lt;/comment&gt;',&#xD;            position.x / scale,&#xD;            position.y / scale,&#xD;            this.textWidth() / scale,&#xD;            this.isCollapsed,&#xD;            this.customData,&#xD;            serializer.escape(this.text())&#xD;        );&#xD;    }&#xD;&#xD;    return serializer.format(&#xD;        '&lt;comment x="@" y="@" w="@" collapsed="@"&gt;%&lt;/comment&gt;',&#xD;        position.x / scale,&#xD;        position.y / scale,&#xD;        this.textWidth() / scale,&#xD;        this.isCollapsed,&#xD;        serializer.escape(this.text())&#xD;    );&#xD;};&#xD;&#xD;&#xD;&#xD;// extensions for, block-definition, scene, stage, sprite, costume, sound, project...&#xD;SnapSerializer.prototype.loadCustomBlocks = function (&#xD;    object,&#xD;    element,&#xD;    isGlobal,&#xD;    isDispatch&#xD;) {&#xD;    // private&#xD;    element.children.forEach(child =&gt; {&#xD;        var definition, names, inputs, vars, header, code, trans, comment, i;&#xD;        if (child.tag !== 'block-definition') {&#xD;            return;&#xD;        }&#xD;        definition = new CustomBlockDefinition(&#xD;            child.attributes.s || '',&#xD;            object&#xD;        );&#xD;        // add custom data def. if available&#xD;        if(child.attributes["customData"]){&#xD;            definition.customData = child.attributes["customData"];&#xD;        }&#xD;        definition.category = child.attributes.category || 'other';&#xD;        if (!SpriteMorph.prototype.allCategories().includes(&#xD;            definition.category&#xD;        )) {&#xD;            definition.category = 'other';&#xD;        }&#xD;        definition.type = child.attributes.type || 'command';&#xD;        definition.isHelper = (child.attributes.helper === 'true') || false;&#xD;        definition.isGlobal = (isGlobal === true);&#xD;        if (isDispatch) {&#xD;            object.inheritedMethodsCache.push(definition);&#xD;        } else {&#xD;            if (definition.isGlobal) {&#xD;                object.globalBlocks.push(definition);&#xD;            } else {&#xD;                object.customBlocks.push(definition);&#xD;            }&#xD;        }&#xD;&#xD;        names = definition.parseSpec(definition.spec).filter(&#xD;            str =&gt; str.charAt(0) === '%' &amp;&amp; str.length &gt; 1&#xD;        ).map(str =&gt; str.substr(1));&#xD;&#xD;        definition.names = names;&#xD;        inputs = child.childNamed('inputs');&#xD;        if (inputs) {&#xD;            i = -1;&#xD;            inputs.children.forEach(child =&gt; {&#xD;                var options = child.childNamed('options');&#xD;                if (child.tag !== 'input') {&#xD;                    return;&#xD;                }&#xD;                i += 1;&#xD;                definition.declarations.set(&#xD;                    names[i],&#xD;                    [&#xD;                        child.attributes.type,&#xD;                        contains(['%b', '%boolUE'], child.attributes.type) ?&#xD;                            (child.contents ? child.contents === 'true' : null)&#xD;                                : child.contents,&#xD;                        options ? options.contents : undefined,&#xD;                        child.attributes.readonly === 'true',&#xD;                        child.attributes.irreplaceable === 'true',&#xD;                        child.attributes.separator&#xD;                    ]&#xD;                );&#xD;            });&#xD;        }&#xD;&#xD;        vars = child.childNamed('variables');&#xD;        if (vars) {&#xD;            definition.variableNames = this.loadValue(&#xD;                vars.require('list')&#xD;            ).asArray();&#xD;        }&#xD;&#xD;        header = child.childNamed('header');&#xD;        if (header) {&#xD;            definition.codeHeader = header.contents;&#xD;        }&#xD;&#xD;        code = child.childNamed('code');&#xD;        if (code) {&#xD;            definition.codeMapping = code.contents;&#xD;        }&#xD;&#xD;        trans = child.childNamed('translations');&#xD;        if (trans) {&#xD;            definition.updateTranslations(trans.contents);&#xD;        }&#xD;&#xD;        comment = child.childNamed('comment');&#xD;        if (comment) {&#xD;            definition.comment = this.loadComment(comment);&#xD;        }&#xD;    });&#xD;};&#xD;&#xD;CustomBlockDefinition.prototype.toXML = function (serializer) {&#xD;    function encodeScripts(array) {&#xD;        return array.reduce((xml, element) =&gt; {&#xD;            if (element instanceof BlockMorph) {&#xD;                return xml + element.toScriptXML(serializer, true);&#xD;            }&#xD;            if (element instanceof CommentMorph &amp;&amp; !element.block) {&#xD;                return xml + element.toXML(serializer);&#xD;            }&#xD;            return xml;&#xD;        }, '');&#xD;    }&#xD;&#xD;    if (this.customData) {&#xD;        return serializer.format(&#xD;            '&lt;block-definition s="@" type="@" category="@" customData="@"%&gt;' +&#xD;                '%' +&#xD;                (this.variableNames.length ? '&lt;variables&gt;%&lt;/variables&gt;' : '@') +&#xD;                '&lt;header&gt;@&lt;/header&gt;' +&#xD;                '&lt;code&gt;@&lt;/code&gt;' +&#xD;                '&lt;translations&gt;@&lt;/translations&gt;' +&#xD;                '&lt;inputs&gt;%&lt;/inputs&gt;%%' +&#xD;                '&lt;/block-definition&gt;',&#xD;            this.spec,&#xD;            this.type,&#xD;            this.category || 'other',&#xD;            this.customData,&#xD;            this.isHelper ? ' helper="true"' : '',&#xD;            this.comment ? this.comment.toXML(serializer) : '',&#xD;            (this.variableNames.length ?&#xD;                    serializer.store(new List(this.variableNames)) : ''),&#xD;            this.codeHeader || '',&#xD;            this.codeMapping || '',&#xD;            this.translationsAsText(),&#xD;            Array.from(this.declarations.keys()).reduce((xml, decl) =&gt; {&#xD;                // to be refactored now that we've moved to ES6 Map:&#xD;                    return xml + serializer.format(&#xD;                        '&lt;input type="@"$$$&gt;$%&lt;/input&gt;',&#xD;                        this.declarations.get(decl)[0],&#xD;                        this.declarations.get(decl)[3] ?&#xD;                                ' readonly="true"' : '',&#xD;                        this.declarations.get(decl)[4] ?&#xD;                                ' irreplaceable="true"' : '',&#xD;                        this.declarations.get(decl)[5] ?&#xD;                                ' separator="' +&#xD;                                    this.declarations.get(decl)[5] +&#xD;                                    '"'&#xD;                                : '',&#xD;                        this.declarations.get(decl)[1],&#xD;                        this.declarations.get(decl)[2] ?&#xD;                                serializer.format(&#xD;                                    '&lt;options&gt;@&lt;/options&gt;',&#xD;                                    this.declarations.get(decl)[2]&#xD;                                ) : ''&#xD;                    );&#xD;                }, ''),&#xD;            this.body ? serializer.store(this.body.expression) : '',&#xD;            this.scripts.length &gt; 0 ?&#xD;                        '&lt;scripts&gt;' + encodeScripts(this.scripts) + '&lt;/scripts&gt;'&#xD;                            : ''&#xD;        );&#xD;    }&#xD;&#xD;    return serializer.format(&#xD;        '&lt;block-definition s="@" type="@" category="@"%&gt;' +&#xD;            '%' +&#xD;            (this.variableNames.length ? '&lt;variables&gt;%&lt;/variables&gt;' : '@') +&#xD;            '&lt;header&gt;@&lt;/header&gt;' +&#xD;            '&lt;code&gt;@&lt;/code&gt;' +&#xD;            '&lt;translations&gt;@&lt;/translations&gt;' +&#xD;            '&lt;inputs&gt;%&lt;/inputs&gt;%%' +&#xD;            '&lt;/block-definition&gt;',&#xD;        this.spec,&#xD;        this.type,&#xD;        this.category || 'other',&#xD;        this.isHelper ? ' helper="true"' : '',&#xD;        this.comment ? this.comment.toXML(serializer) : '',&#xD;        (this.variableNames.length ?&#xD;                serializer.store(new List(this.variableNames)) : ''),&#xD;        this.codeHeader || '',&#xD;        this.codeMapping || '',&#xD;        this.translationsAsText(),&#xD;        Array.from(this.declarations.keys()).reduce((xml, decl) =&gt; {&#xD;            // to be refactored now that we've moved to ES6 Map:&#xD;                return xml + serializer.format(&#xD;                    '&lt;input type="@"$$$&gt;$%&lt;/input&gt;',&#xD;                    this.declarations.get(decl)[0],&#xD;                    this.declarations.get(decl)[3] ?&#xD;                            ' readonly="true"' : '',&#xD;                    this.declarations.get(decl)[4] ?&#xD;                            ' irreplaceable="true"' : '',&#xD;                    this.declarations.get(decl)[5] ?&#xD;                            ' separator="' +&#xD;                                this.declarations.get(decl)[5] +&#xD;                                '"'&#xD;                            : '',&#xD;                    this.declarations.get(decl)[1],&#xD;                    this.declarations.get(decl)[2] ?&#xD;                            serializer.format(&#xD;                                '&lt;options&gt;@&lt;/options&gt;',&#xD;                                this.declarations.get(decl)[2]&#xD;                            ) : ''&#xD;                );&#xD;            }, ''),&#xD;        this.body ? serializer.store(this.body.expression) : '',&#xD;        this.scripts.length &gt; 0 ?&#xD;                    '&lt;scripts&gt;' + encodeScripts(this.scripts) + '&lt;/scripts&gt;'&#xD;                        : ''&#xD;    );&#xD;};&#xD;&#xD;Scene.prototype.toXML = function (serializer) {&#xD;    var xml;&#xD;&#xD;    function code(key) {&#xD;        var str = '';&#xD;        Object.keys(StageMorph.prototype[key]).forEach(&#xD;            selector =&gt; {&#xD;                str += (&#xD;                    '&lt;' + selector + '&gt;' +&#xD;                        XML_Element.prototype.escape(&#xD;                            StageMorph.prototype[key][selector]&#xD;                        ) +&#xD;                        '&lt;/' + selector + '&gt;'&#xD;                );&#xD;            }&#xD;        );&#xD;        return str;&#xD;    }&#xD;&#xD;    serializer.scene = this; // keep the order of sprites in the corral&#xD;&#xD;    if(this.customData){&#xD;        xml = serializer.format(&#xD;            '&lt;scene name="@" customData="@"%%%%%%&gt;' +&#xD;                '&lt;notes&gt;$&lt;/notes&gt;' +&#xD;                '%' +&#xD;                '&lt;hidden&gt;$&lt;/hidden&gt;' +&#xD;                '&lt;headers&gt;%&lt;/headers&gt;' +&#xD;                '&lt;code&gt;%&lt;/code&gt;' +&#xD;                '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;                '%' + // stage&#xD;                '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;                '&lt;/scene&gt;',&#xD;            this.name || localize('Untitled'),&#xD;            this.customData,&#xD;            this.unifiedPalette ? ' palette="single"' : '',&#xD;            this.unifiedPalette &amp;&amp; !this.showCategories ?&#xD;                ' categories="false"' : '',&#xD;            this.unifiedPalette &amp;&amp; !this.showPaletteButtons ?&#xD;                ' buttons="false"' : '',&#xD;            this.disableClickToRun ? ' clickrun="false"' : '',&#xD;            this.disableDraggingData ? ' dragdata="false"' : '',&#xD;            this.penColorModel === 'hsl' ? ' colormodel="hsl"' : '',&#xD;            this.notes || '',&#xD;            serializer.paletteToXML(this.customCategories),&#xD;            Object.keys(this.hiddenPrimitives).reduce(&#xD;                    (a, b) =&gt; a + ' ' + b,&#xD;                    ''&#xD;                ),&#xD;            code('codeHeaders'),&#xD;            code('codeMappings'),&#xD;            serializer.store(this.stage.globalBlocks),&#xD;            serializer.store(this.stage),&#xD;            serializer.store(this.globalVariables)&#xD;        );&#xD;    } else {&#xD;        xml = serializer.format(&#xD;            '&lt;scene name="@"%%%%%%&gt;' +&#xD;                '&lt;notes&gt;$&lt;/notes&gt;' +&#xD;                '%' +&#xD;                '&lt;hidden&gt;$&lt;/hidden&gt;' +&#xD;                '&lt;headers&gt;%&lt;/headers&gt;' +&#xD;                '&lt;code&gt;%&lt;/code&gt;' +&#xD;                '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;                '%' + // stage&#xD;                '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;                '&lt;/scene&gt;',&#xD;            this.name || localize('Untitled'),&#xD;            this.unifiedPalette ? ' palette="single"' : '',&#xD;            this.unifiedPalette &amp;&amp; !this.showCategories ?&#xD;                ' categories="false"' : '',&#xD;            this.unifiedPalette &amp;&amp; !this.showPaletteButtons ?&#xD;                ' buttons="false"' : '',&#xD;            this.disableClickToRun ? ' clickrun="false"' : '',&#xD;            this.disableDraggingData ? ' dragdata="false"' : '',&#xD;            this.penColorModel === 'hsl' ? ' colormodel="hsl"' : '',&#xD;            this.notes || '',&#xD;            serializer.paletteToXML(this.customCategories),&#xD;            Object.keys(this.hiddenPrimitives).reduce(&#xD;                    (a, b) =&gt; a + ' ' + b,&#xD;                    ''&#xD;                ),&#xD;            code('codeHeaders'),&#xD;            code('codeMappings'),&#xD;            serializer.store(this.stage.globalBlocks),&#xD;            serializer.store(this.stage),&#xD;            serializer.store(this.globalVariables)&#xD;        );&#xD;    }&#xD;    return xml;&#xD;};&#xD;&#xD;SnapSerializer.prototype.loadScene = function (xmlNode, appVersion, remixID) {&#xD;    // private&#xD;    var scene = new Scene(),&#xD;        model,&#xD;        hidden,&#xD;        nameID;&#xD;&#xD;    this.scene = scene;&#xD;&#xD;    model = {scene: xmlNode };&#xD;    if (+xmlNode.attributes.version &gt; this.version) {&#xD;        throw 'Project uses newer version of Serializer';&#xD;    }&#xD;&#xD;    /* Project Info */&#xD;&#xD;    this.objects = {};&#xD;    scene.name = model.scene.attributes.name;&#xD;    if (!scene.name) {&#xD;        nameID = 1;&#xD;        while (&#xD;            Object.prototype.hasOwnProperty.call(&#xD;                localStorage,&#xD;                '-snap-project-Untitled ' + nameID&#xD;            )&#xD;        ) {&#xD;            nameID += 1;&#xD;        }&#xD;        scene.name = 'Untitled ' + nameID;&#xD;    }&#xD;    if(model.scene.attributes["customData"]){&#xD;        scene.customData = model.scene.attributes["customData"];&#xD;    }&#xD;    scene.unifiedPalette = model.scene.attributes.palette === 'single';&#xD;    scene.showCategories = model.scene.attributes.categories !== 'false';&#xD;    scene.showPaletteButtons = model.scene.attributes.buttons !== 'false';&#xD;    scene.disableClickToRun = model.scene.attributes.clickrun === 'false';&#xD;    scene.disableDraggingData = model.scene.attributes.dragdata === 'false';&#xD;    scene.penColorModel = model.scene.attributes.colormodel === 'hsl' ?&#xD;        'hsl' : 'hsv';&#xD;    model.notes = model.scene.childNamed('notes');&#xD;    if (model.notes) {&#xD;        scene.notes = model.notes.contents;&#xD;    }&#xD;    model.palette = model.scene.childNamed('palette');&#xD;    if (model.palette) {&#xD;        scene.customCategories = this.loadPalette(model.palette);&#xD;        SpriteMorph.prototype.customCategories = scene.customCategories;&#xD;    }&#xD;    model.globalVariables = model.scene.childNamed('variables');&#xD;&#xD;    /* Stage */&#xD;&#xD;    model.stage = model.scene.require('stage');&#xD;    scene.stage.remixID = remixID;&#xD;&#xD;    if (Object.prototype.hasOwnProperty.call(&#xD;            model.stage.attributes,&#xD;            'id'&#xD;        )) {&#xD;        this.objects[model.stage.attributes.id] = scene.stage;&#xD;    }&#xD;    if (model.stage.attributes.customData){&#xD;        scene.stage.customData = model.stage.attributes.customData;&#xD;    }&#xD;    if (model.stage.attributes.name) {&#xD;        scene.stage.name = model.stage.attributes.name;&#xD;    }&#xD;    if (model.stage.attributes.color) {&#xD;        scene.stage.color = this.loadColor(model.stage.attributes.color);&#xD;        scene.stage.cachedColorDimensions = scene.stage.color[&#xD;            SpriteMorph.prototype.penColorModel&#xD;        ]();&#xD;    }&#xD;    if (model.stage.attributes.volume) {&#xD;        scene.stage.volume = +model.stage.attributes.volume;&#xD;    }&#xD;    if (model.stage.attributes.pan) {&#xD;        scene.stage.pan = +model.stage.attributes.pan;&#xD;    }&#xD;    if (model.stage.attributes.penlog) {&#xD;        scene.enablePenLogging =&#xD;            (model.stage.attributes.penlog === 'true');&#xD;    }&#xD;&#xD;    model.pentrails = model.stage.childNamed('pentrails');&#xD;    if (model.pentrails) {&#xD;        scene.pentrails = new Image();&#xD;        scene.pentrails.onload = function () {&#xD;            if (scene.stage.trailsCanvas) { // work-around a bug in FF&#xD;                normalizeCanvas(scene.stage.trailsCanvas);&#xD;                var context = scene.stage.trailsCanvas.getContext('2d');&#xD;                context.drawImage(scene.pentrails, 0, 0);&#xD;                scene.stage.changed();&#xD;            }&#xD;        };&#xD;        scene.pentrails.src = model.pentrails.contents;&#xD;    }&#xD;    scene.stage.setTempo(model.stage.attributes.tempo);&#xD;    if (model.stage.attributes.width) {&#xD;        scene.stage.dimensions.x =&#xD;            Math.max(+model.stage.attributes.width, 240);&#xD;    }&#xD;    if (model.stage.attributes.height) {&#xD;        scene.stage.dimensions.y =&#xD;            Math.max(+model.stage.attributes.height, 180);&#xD;    }&#xD;    scene.stage.setExtent(scene.stage.dimensions);&#xD;    scene.useFlatLineEnds =&#xD;        model.stage.attributes.lines === 'flat';&#xD;    BooleanSlotMorph.prototype.isTernary =&#xD;        model.stage.attributes.ternary !== 'false';&#xD;    scene.enableHyperOps =&#xD;        model.stage.attributes.hyperops !== 'falses';&#xD;    scene.stage.isThreadSafe =&#xD;        model.stage.attributes.threadsafe === 'true';&#xD;    scene.enableCodeMapping =&#xD;        model.stage.attributes.codify === 'true';&#xD;    scene.enableInheritance =&#xD;        model.stage.attributes.inheritance !== 'false';&#xD;    scene.enableSublistIDs =&#xD;        model.stage.attributes.sublistIDs === 'true';&#xD;&#xD;    model.hiddenPrimitives = model.scene.childNamed('hidden');&#xD;    if (model.hiddenPrimitives) {&#xD;        hidden = model.hiddenPrimitives.contents.split(' ').filter(word =&gt;&#xD;            word.length &gt; 0);&#xD;        if (hidden.length) {&#xD;            hidden.forEach(&#xD;                sel =&gt; {&#xD;                    var selector, migration;&#xD;                    if (sel) {&#xD;                        migration = SpriteMorph.prototype.blockMigrations[sel];&#xD;                        selector = migration ? migration.selector : sel;&#xD;                        scene.hiddenPrimitives[selector] = true;&#xD;                    }&#xD;                }&#xD;            );&#xD;&#xD;            // hide new primitives that have been added to the palette&#xD;            // since the project has been last saved&#xD;            SpriteMorph.prototype.newPrimitivesSince(appVersion).forEach(&#xD;                sel =&gt; {&#xD;                    var selector, migration;&#xD;                    if (sel) {&#xD;                        migration = SpriteMorph.prototype.blockMigrations[sel];&#xD;                        selector = migration ? migration.selector : sel;&#xD;                        scene.hiddenPrimitives[selector] = true;&#xD;                    }&#xD;                }&#xD;            );&#xD;        }&#xD;    }&#xD;&#xD;    model.codeHeaders = model.scene.childNamed('headers');&#xD;    if (model.codeHeaders) {&#xD;        model.codeHeaders.children.forEach(&#xD;            xml =&gt; scene.codeHeaders[xml.tag] = xml.contents&#xD;        );&#xD;    }&#xD;&#xD;    model.codeMappings = model.scene.childNamed('code');&#xD;    if (model.codeMappings) {&#xD;        model.codeMappings.children.forEach(&#xD;            xml =&gt; scene.codeMappings[xml.tag] = xml.contents&#xD;        );&#xD;    }&#xD;&#xD;    model.globalBlocks = model.scene.childNamed('blocks');&#xD;    if (model.globalBlocks) {&#xD;        this.loadCustomBlocks(scene.stage, model.globalBlocks, true);&#xD;        this.populateCustomBlocks(&#xD;            scene.stage,&#xD;            model.globalBlocks,&#xD;            true&#xD;        );&#xD;    }&#xD;    this.loadObject(scene.stage, model.stage);&#xD;&#xD;    /* Sprites */&#xD;&#xD;    model.sprites = model.stage.require('sprites');&#xD;    if (model.sprites.attributes.select) {&#xD;        scene.spriteIdx = +model.sprites.attributes.select;&#xD;    }&#xD;    scene.spritesDict[scene.stage.name] = scene.stage;&#xD;    model.sprites.childrenNamed('sprite').forEach(&#xD;        model =&gt; this.loadValue(model)&#xD;    );&#xD;&#xD;    // restore inheritance and nesting associations&#xD;    this.scene.stage.children.forEach(sprite =&gt; {&#xD;        var matchingModelData = model.sprites.childrenNamed('sprite').filter(&#xD;            model =&gt; model.attributes["name"] == sprite.name&#xD;        );&#xD;        if(matchingModelData.length &gt; 0){&#xD;            var matchingSpriteData = matchingModelData[0];&#xD;            if(matchingSpriteData.attributes["customData"]){&#xD;                sprite.customData = matchingSpriteData.attributes["customData"];&#xD;            }&#xD;        }&#xD;        var exemplar, anchor;&#xD;        if (sprite.inheritanceInfo) { // only sprites can inherit&#xD;            exemplar = this.scene.spritesDict[&#xD;                sprite.inheritanceInfo.exemplar&#xD;            ];&#xD;            if (exemplar) {&#xD;                sprite.setExemplar(exemplar);&#xD;            }&#xD;            sprite.inheritedAttributes = sprite.inheritanceInfo.delegated || [];&#xD;            sprite.updatePropagationCache();&#xD;        }&#xD;        if (sprite.nestingInfo) { // only sprites may have nesting info&#xD;            anchor = this.scene.spritesDict[sprite.nestingInfo.anchor];&#xD;            if (anchor) {&#xD;                anchor.attachPart(sprite);&#xD;            }&#xD;            sprite.rotatesWithAnchor = (sprite.nestingInfo.synch === 'true');&#xD;        }&#xD;    });&#xD;    this.scene.stage.children.forEach(sprite =&gt; {&#xD;        var costume;&#xD;        if (sprite.nestingInfo) { // only sprites may have nesting info&#xD;            sprite.nestingScale = +(sprite.nestingInfo.scale || sprite.scale);&#xD;            delete sprite.nestingInfo;&#xD;        }&#xD;        ['scripts', 'costumes', 'sounds'].forEach(att =&gt; {&#xD;            if (sprite.inheritsAttribute(att)) {&#xD;                sprite.refreshInheritedAttribute(att);&#xD;            }&#xD;        });&#xD;        if (sprite.inheritsAttribute('costumes')) {&#xD;            if (sprite.inheritsAttribute('costume #')) {&#xD;                costume = sprite.exemplar.costume;&#xD;            } else {&#xD;                costume = sprite.costumes.asArray()[&#xD;                    sprite.inheritanceInfo.costumeNumber - 1&#xD;                ];&#xD;            }&#xD;            if (costume) {&#xD;                if (costume.loaded) {&#xD;                    sprite.wearCostume(costume, true);&#xD;                } else {&#xD;                    costume.loaded = function () {&#xD;                        this.loaded = true;&#xD;                        sprite.wearCostume(costume, true);&#xD;                    };&#xD;                }&#xD;            }&#xD;        }&#xD;        delete sprite.inheritanceInfo;&#xD;    });&#xD;&#xD;    /* Global Variables */&#xD;&#xD;    if (model.globalVariables) {&#xD;        this.loadVariables(&#xD;            scene.globalVariables,&#xD;            model.globalVariables&#xD;        );&#xD;    }&#xD;&#xD;    this.objects = {};&#xD;&#xD;    /* Watchers */&#xD;&#xD;    model.sprites.childrenNamed('watcher').forEach(model =&gt; {&#xD;        var watcher, color, target, hidden, extX, extY;&#xD;&#xD;        color = this.loadColor(model.attributes.color);&#xD;        target = Object.prototype.hasOwnProperty.call(&#xD;            model.attributes,&#xD;            'scope'&#xD;        ) ? scene.spritesDict[model.attributes.scope] : null;&#xD;&#xD;        // determine whether the watcher is hidden, slightly&#xD;        // complicated to retain backward compatibility&#xD;        // with former tag format: hidden="hidden"&#xD;        // now it's: hidden="true"&#xD;        hidden = Object.prototype.hasOwnProperty.call(&#xD;            model.attributes,&#xD;            'hidden'&#xD;        ) &amp;&amp; (model.attributes.hidden !== 'false');&#xD;&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'var'&#xD;            )) {&#xD;            watcher = new WatcherMorph(&#xD;                model.attributes['var'],&#xD;                color,&#xD;                isNil(target) ? scene.globalVariables&#xD;                    : target.variables,&#xD;                model.attributes['var'],&#xD;                hidden&#xD;            );&#xD;        } else {&#xD;            watcher = new WatcherMorph(&#xD;                localize(this.watcherLabels[model.attributes.s]),&#xD;                color,&#xD;                target,&#xD;                model.attributes.s,&#xD;                hidden&#xD;            );&#xD;        }&#xD;        watcher.setStyle(model.attributes.style || 'normal');&#xD;        if (watcher.style === 'slider') {&#xD;            watcher.setSliderMin(model.attributes.min || '1', true);&#xD;            watcher.setSliderMax(model.attributes.max || '100', true);&#xD;        }&#xD;        watcher.setPosition(&#xD;            scene.stage.topLeft().add(new Point(&#xD;                +model.attributes.x || 0,&#xD;                +model.attributes.y || 0&#xD;            )).multiplyBy(scene.stage.scale)&#xD;        );&#xD;        scene.stage.add(watcher);&#xD;        watcher.onNextStep = function () {this.currentValue = null; };&#xD;&#xD;        // set watcher's contentsMorph's extent if it is showing a list and&#xD;        // its monitor dimensions are given&#xD;        if (watcher.currentValue instanceof List &amp;&amp;&#xD;                watcher.cellMorph.contentsMorph) {&#xD;            extX = model.attributes.extX;&#xD;            if (extX) {&#xD;                watcher.cellMorph.contentsMorph.setWidth(+extX);&#xD;            }&#xD;            extY = model.attributes.extY;&#xD;            if (extY) {&#xD;                watcher.cellMorph.contentsMorph.setHeight(+extY);&#xD;            }&#xD;            // adjust my contentsMorph's handle position&#xD;            watcher.cellMorph.contentsMorph.handle.fixLayout();&#xD;        }&#xD;    });&#xD;&#xD;    // clear sprites' inherited methods caches, if any&#xD;    this.scene.stage.children.forEach(&#xD;        sprite =&gt; sprite.inheritedMethodsCache = []&#xD;    );&#xD;&#xD;    this.objects = {};&#xD;    return scene.initialize();&#xD;};&#xD;&#xD;StageMorph.prototype.toXML = function (serializer) {&#xD;    var costumeIdx = this.getCostumeIdx();&#xD;&#xD;    this.removeAllClones();&#xD;    if(this.customData){&#xD;        return serializer.format(&#xD;            '&lt;stage name="@" width="@" height="@" ' +&#xD;            'costume="@" color="@,@,@,@" tempo="@" threadsafe="@" ' +&#xD;            'penlog="@" ' +&#xD;            '%' +&#xD;            'volume="@" ' +&#xD;            'pan="@" ' +&#xD;            'lines="@" ' +&#xD;            'ternary="@" ' +&#xD;            'hyperops="@" ' +&#xD;            'codify="@" ' +&#xD;            'inheritance="@" ' +&#xD;            'sublistIDs="@" customData="@" ~&gt;' +&#xD;            '&lt;pentrails&gt;$&lt;/pentrails&gt;' +&#xD;            '%' + // current costume, if it's not in the wardrobe&#xD;            '&lt;costumes&gt;%&lt;/costumes&gt;' +&#xD;            '&lt;sounds&gt;%&lt;/sounds&gt;' +&#xD;            '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;            '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;            '&lt;scripts&gt;%&lt;/scripts&gt;' +&#xD;            '&lt;sprites select="@"&gt;%&lt;/sprites&gt;' +&#xD;            '&lt;/stage&gt;',&#xD;        this.name,&#xD;        this.dimensions.x,&#xD;        this.dimensions.y,&#xD;        costumeIdx,&#xD;        this.color.r,&#xD;        this.color.g,&#xD;        this.color.b,&#xD;        this.color.a,&#xD;        this.getTempo(),&#xD;        this.isThreadSafe,&#xD;        this.enablePenLogging,&#xD;        this.instrument ?&#xD;                ' instrument="' + parseInt(this.instrument) + '" ' : '',&#xD;        this.volume,&#xD;        this.pan,&#xD;        SpriteMorph.prototype.useFlatLineEnds ? 'flat' : 'round',&#xD;        BooleanSlotMorph.prototype.isTernary,&#xD;        Process.prototype.enableHyperOps === true,&#xD;        this.enableCodeMapping,&#xD;        this.enableInheritance,&#xD;        this.enableSublistIDs,&#xD;        this.customData,&#xD;        normalizeCanvas(this.trailsCanvas, true).toDataURL('image/png'),&#xD;&#xD;        // current costume, if it's not in the wardrobe&#xD;        !costumeIdx &amp;&amp; this.costume ?&#xD;            '&lt;wear&gt;' + serializer.store(this.costume) + '&lt;/wear&gt;'&#xD;                : '',&#xD;&#xD;        serializer.store(this.costumes, this.name + '_cst'),&#xD;        serializer.store(this.sounds, this.name + '_snd'),&#xD;        serializer.store(this.variables),&#xD;        serializer.store(this.customBlocks),&#xD;        serializer.store(this.scripts),&#xD;        serializer.root.sprites.asArray().indexOf(&#xD;            serializer.root.currentSprite) + 1,&#xD;        serializer.store(this.children)&#xD;    );&#xD;    }&#xD;    return serializer.format(&#xD;            '&lt;stage name="@" width="@" height="@" ' +&#xD;            'costume="@" color="@,@,@,@" tempo="@" threadsafe="@" ' +&#xD;            'penlog="@" ' +&#xD;            '%' +&#xD;            'volume="@" ' +&#xD;            'pan="@" ' +&#xD;            'lines="@" ' +&#xD;            'ternary="@" ' +&#xD;            'hyperops="@" ' +&#xD;            'codify="@" ' +&#xD;            'inheritance="@" ' +&#xD;            'sublistIDs="@" ~&gt;' +&#xD;            '&lt;pentrails&gt;$&lt;/pentrails&gt;' +&#xD;            '%' + // current costume, if it's not in the wardrobe&#xD;            '&lt;costumes&gt;%&lt;/costumes&gt;' +&#xD;            '&lt;sounds&gt;%&lt;/sounds&gt;' +&#xD;            '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;            '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;            '&lt;scripts&gt;%&lt;/scripts&gt;' +&#xD;            '&lt;sprites select="@"&gt;%&lt;/sprites&gt;' +&#xD;            '&lt;/stage&gt;',&#xD;        this.name,&#xD;        this.dimensions.x,&#xD;        this.dimensions.y,&#xD;        costumeIdx,&#xD;        this.color.r,&#xD;        this.color.g,&#xD;        this.color.b,&#xD;        this.color.a,&#xD;        this.getTempo(),&#xD;        this.isThreadSafe,&#xD;        this.enablePenLogging,&#xD;        this.instrument ?&#xD;                ' instrument="' + parseInt(this.instrument) + '" ' : '',&#xD;        this.volume,&#xD;        this.pan,&#xD;        SpriteMorph.prototype.useFlatLineEnds ? 'flat' : 'round',&#xD;        BooleanSlotMorph.prototype.isTernary,&#xD;        Process.prototype.enableHyperOps === true,&#xD;        this.enableCodeMapping,&#xD;        this.enableInheritance,&#xD;        this.enableSublistIDs,&#xD;        normalizeCanvas(this.trailsCanvas, true).toDataURL('image/png'),&#xD;&#xD;        // current costume, if it's not in the wardrobe&#xD;        !costumeIdx &amp;&amp; this.costume ?&#xD;            '&lt;wear&gt;' + serializer.store(this.costume) + '&lt;/wear&gt;'&#xD;                : '',&#xD;&#xD;        serializer.store(this.costumes, this.name + '_cst'),&#xD;        serializer.store(this.sounds, this.name + '_snd'),&#xD;        serializer.store(this.variables),&#xD;        serializer.store(this.customBlocks),&#xD;        serializer.store(this.scripts),&#xD;        serializer.root.sprites.asArray().indexOf(&#xD;            serializer.root.currentSprite) + 1,&#xD;        serializer.store(this.children)&#xD;    );&#xD;};&#xD;&#xD;StageMorph.prototype.toSpriteXML = function (serializer) {&#xD;    // special case: export the stage as a sprite, so it can be&#xD;    // imported into another project or scene&#xD;    var costumeIdx = this.getCostumeIdx();&#xD;&#xD;    if(this.customData){&#xD;        return serializer.format(&#xD;            '&lt;sprite name="@" idx="1" x="0" y="0"' +&#xD;                ' heading="90"' +&#xD;                ' scale="1"' +&#xD;                ' volume="@"' +&#xD;                ' pan="@"' +&#xD;                ' rotation="0"' +&#xD;                '%' +&#xD;                ' draggable="true"' +&#xD;                ' costume="@" color="80,80,80,1" pen="tip" customData="@" ~&gt;' +&#xD;                '%' + // current costume&#xD;                '&lt;costumes&gt;%&lt;/costumes&gt;' +&#xD;                '&lt;sounds&gt;%&lt;/sounds&gt;' +&#xD;                '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;                '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;                '&lt;scripts&gt;%&lt;/scripts&gt;' +&#xD;                '&lt;/sprite&gt;',&#xD;            this.name,&#xD;            this.volume,&#xD;            this.pan,&#xD;            this.instrument ?&#xD;                    ' instrument="' + parseInt(this.instrument) + '" ' : '',&#xD;            costumeIdx,&#xD;            this.customData,&#xD;    &#xD;            // current costume, if it's not in the wardrobe&#xD;            !costumeIdx &amp;&amp; this.costume ?&#xD;                '&lt;wear&gt;' + serializer.store(this.costume) + '&lt;/wear&gt;'&#xD;                    : '',&#xD;    &#xD;            serializer.store(this.costumes, this.name + '_cst'),&#xD;            serializer.store(this.sounds, this.name + '_snd'),&#xD;            !this.customBlocks ? '' : serializer.store(this.customBlocks),&#xD;            serializer.store(this.variables),&#xD;            serializer.store(this.scripts)&#xD;        );&#xD;    }&#xD;    return serializer.format(&#xD;        '&lt;sprite name="@" idx="1" x="0" y="0"' +&#xD;            ' heading="90"' +&#xD;            ' scale="1"' +&#xD;            ' volume="@"' +&#xD;            ' pan="@"' +&#xD;            ' rotation="0"' +&#xD;            '%' +&#xD;            ' draggable="true"' +&#xD;            ' costume="@" color="80,80,80,1" pen="tip" ~&gt;' +&#xD;            '%' + // current costume&#xD;            '&lt;costumes&gt;%&lt;/costumes&gt;' +&#xD;            '&lt;sounds&gt;%&lt;/sounds&gt;' +&#xD;            '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;            '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;            '&lt;scripts&gt;%&lt;/scripts&gt;' +&#xD;            '&lt;/sprite&gt;',&#xD;        this.name,&#xD;        this.volume,&#xD;        this.pan,&#xD;        this.instrument ?&#xD;                ' instrument="' + parseInt(this.instrument) + '" ' : '',&#xD;        costumeIdx,&#xD;&#xD;        // current costume, if it's not in the wardrobe&#xD;        !costumeIdx &amp;&amp; this.costume ?&#xD;            '&lt;wear&gt;' + serializer.store(this.costume) + '&lt;/wear&gt;'&#xD;                : '',&#xD;&#xD;        serializer.store(this.costumes, this.name + '_cst'),&#xD;        serializer.store(this.sounds, this.name + '_snd'),&#xD;        !this.customBlocks ? '' : serializer.store(this.customBlocks),&#xD;        serializer.store(this.variables),&#xD;        serializer.store(this.scripts)&#xD;    );&#xD;};&#xD;&#xD;SpriteMorph.prototype.toXML = function (serializer) {&#xD;    var idx = serializer.scene.sprites.asArray().indexOf(this) + 1,&#xD;        costumeIdx = this.getCostumeIdx(),&#xD;        noCostumes = this.inheritsAttribute('costumes'),&#xD;        noSounds = this.inheritsAttribute('sounds'),&#xD;        noScripts = this.inheritsAttribute('scripts');&#xD;&#xD;        if(this.customData){&#xD;            return serializer.format(&#xD;                '&lt;sprite name="@" idx="@" x="@" y="@"' +&#xD;                    ' heading="@"' +&#xD;                    ' scale="@"' +&#xD;                    ' volume="@"' +&#xD;                    ' pan="@"' +&#xD;                    ' rotation="@"' +&#xD;                    '%' +&#xD;                    ' draggable="@"' +&#xD;                    '%' +&#xD;                    ' costume="@" color="@,@,@,@" pen="@" customData="@" ~&gt;' +&#xD;                    '%' + // solution info&#xD;                    '%' + // inheritance info&#xD;                    '%' + // nesting info&#xD;                    '%' + // current costume&#xD;                    (noCostumes ? '%' : '&lt;costumes&gt;%&lt;/costumes&gt;') +&#xD;                    (noSounds ? '%' : '&lt;sounds&gt;%&lt;/sounds&gt;') +&#xD;                    '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;                    '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;                    (this.exemplar ? '&lt;dispatches&gt;%&lt;/dispatches&gt;' : '%') +&#xD;                    (noScripts ? '%' : '&lt;scripts&gt;%&lt;/scripts&gt;') +&#xD;                    '&lt;/sprite&gt;',&#xD;                this.name,&#xD;                idx,&#xD;                this.xPosition(),&#xD;                this.yPosition(),&#xD;                this.heading,&#xD;                this.scale,&#xD;                this.volume,&#xD;                this.pan,&#xD;                this.rotationStyle,&#xD;                this.instrument ?&#xD;                        ' instrument="' + parseInt(this.instrument) + '" ' : '',&#xD;                this.isDraggable,&#xD;                this.isVisible ? '' : ' hidden="true"',&#xD;                costumeIdx,&#xD;                this.color.r,&#xD;                this.color.g,&#xD;                this.color.b,&#xD;                this.color.a,&#xD;                this.penPoint,&#xD;                this.customData,&#xD;        &#xD;                // solution info&#xD;                this.solution&#xD;                    ? '&lt;solution&gt;' + serializer.store(this.solution) + '&lt;/solution&gt;'&#xD;                    : '',&#xD;        &#xD;                // inheritance info&#xD;                this.exemplar&#xD;                    ? '&lt;inherit exemplar="' +&#xD;                            this.exemplar.name +&#xD;                            '"&gt;' +&#xD;                            (this.inheritedAttributes.length ?&#xD;                                serializer.store(new List(this.inheritedAttributes))&#xD;                                : '') +&#xD;                            '&lt;/inherit&gt;'&#xD;                    : '',&#xD;        &#xD;                // nesting info&#xD;                this.anchor&#xD;                    ? '&lt;nest anchor="' +&#xD;                            this.anchor.name +&#xD;                            '" synch="'&#xD;                            + this.rotatesWithAnchor&#xD;                            + (this.scale === this.nestingScale ? '' :&#xD;                                    '"'&#xD;                                    + ' scale="'&#xD;                                    + this.nestingScale)&#xD;        &#xD;                            + '"/&gt;'&#xD;                    : '',&#xD;        &#xD;                // current costume, if it's not in the wardrobe&#xD;                !costumeIdx &amp;&amp; this.costume ?&#xD;                    '&lt;wear&gt;' + serializer.store(this.costume) + '&lt;/wear&gt;'&#xD;                        : '',&#xD;        &#xD;                noCostumes ? '' : serializer.store(this.costumes, this.name + '_cst'),&#xD;                noSounds ? '' : serializer.store(this.sounds, this.name + '_snd'),&#xD;                !this.customBlocks ? '' : serializer.store(this.customBlocks),&#xD;                serializer.store(this.variables),&#xD;                this.exemplar ? serializer.store(this.inheritedMethods()) : '',&#xD;                noScripts ? '' : serializer.store(this.scripts)&#xD;            );&#xD;        }&#xD;        return serializer.format(&#xD;            '&lt;sprite name="@" idx="@" x="@" y="@"' +&#xD;                ' heading="@"' +&#xD;                ' scale="@"' +&#xD;                ' volume="@"' +&#xD;                ' pan="@"' +&#xD;                ' rotation="@"' +&#xD;                '%' +&#xD;                ' draggable="@"' +&#xD;                '%' +&#xD;                ' costume="@" color="@,@,@,@" pen="@" ~&gt;' +&#xD;                '%' + // solution info&#xD;                '%' + // inheritance info&#xD;                '%' + // nesting info&#xD;                '%' + // current costume&#xD;                (noCostumes ? '%' : '&lt;costumes&gt;%&lt;/costumes&gt;') +&#xD;                (noSounds ? '%' : '&lt;sounds&gt;%&lt;/sounds&gt;') +&#xD;                '&lt;blocks&gt;%&lt;/blocks&gt;' +&#xD;                '&lt;variables&gt;%&lt;/variables&gt;' +&#xD;                (this.exemplar ? '&lt;dispatches&gt;%&lt;/dispatches&gt;' : '%') +&#xD;                (noScripts ? '%' : '&lt;scripts&gt;%&lt;/scripts&gt;') +&#xD;                '&lt;/sprite&gt;',&#xD;            this.name,&#xD;            idx,&#xD;            this.xPosition(),&#xD;            this.yPosition(),&#xD;            this.heading,&#xD;            this.scale,&#xD;            this.volume,&#xD;            this.pan,&#xD;            this.rotationStyle,&#xD;            this.instrument ?&#xD;                    ' instrument="' + parseInt(this.instrument) + '" ' : '',&#xD;            this.isDraggable,&#xD;            this.isVisible ? '' : ' hidden="true"',&#xD;            costumeIdx,&#xD;            this.color.r,&#xD;            this.color.g,&#xD;            this.color.b,&#xD;            this.color.a,&#xD;            this.penPoint,&#xD;    &#xD;            // solution info&#xD;            this.solution&#xD;                ? '&lt;solution&gt;' + serializer.store(this.solution) + '&lt;/solution&gt;'&#xD;                : '',&#xD;    &#xD;            // inheritance info&#xD;            this.exemplar&#xD;                ? '&lt;inherit exemplar="' +&#xD;                        this.exemplar.name +&#xD;                        '"&gt;' +&#xD;                        (this.inheritedAttributes.length ?&#xD;                            serializer.store(new List(this.inheritedAttributes))&#xD;                            : '') +&#xD;                        '&lt;/inherit&gt;'&#xD;                : '',&#xD;    &#xD;            // nesting info&#xD;            this.anchor&#xD;                ? '&lt;nest anchor="' +&#xD;                        this.anchor.name +&#xD;                        '" synch="'&#xD;                        + this.rotatesWithAnchor&#xD;                        + (this.scale === this.nestingScale ? '' :&#xD;                                '"'&#xD;                                + ' scale="'&#xD;                                + this.nestingScale)&#xD;    &#xD;                        + '"/&gt;'&#xD;                : '',&#xD;    &#xD;            // current costume, if it's not in the wardrobe&#xD;            !costumeIdx &amp;&amp; this.costume ?&#xD;                '&lt;wear&gt;' + serializer.store(this.costume) + '&lt;/wear&gt;'&#xD;                    : '',&#xD;    &#xD;            noCostumes ? '' : serializer.store(this.costumes, this.name + '_cst'),&#xD;            noSounds ? '' : serializer.store(this.sounds, this.name + '_snd'),&#xD;            !this.customBlocks ? '' : serializer.store(this.customBlocks),&#xD;            serializer.store(this.variables),&#xD;            this.exemplar ? serializer.store(this.inheritedMethods()) : '',&#xD;            noScripts ? '' : serializer.store(this.scripts)&#xD;        );&#xD;};&#xD;&#xD;Costume.prototype.toXML = function (serializer) {&#xD;    if(this.customData){&#xD;        return serializer.format(&#xD;            '&lt;costume name="@" center-x="@" center-y="@" customData="@" image="@"% ~/&gt;',&#xD;            this.name,&#xD;            this.rotationCenter.x,&#xD;            this.rotationCenter.y,&#xD;            this.customData,&#xD;            this instanceof SVG_Costume ? this.contents.src&#xD;                    : normalizeCanvas(this.contents).toDataURL('image/png'),&#xD;            this.embeddedData ? serializer.format(' embed="@"', this.embeddedData)&#xD;                : ''&#xD;        );&#xD;    }&#xD;    return serializer.format(&#xD;        '&lt;costume name="@" center-x="@" center-y="@" image="@"% ~/&gt;',&#xD;        this.name,&#xD;        this.rotationCenter.x,&#xD;        this.rotationCenter.y,&#xD;        this instanceof SVG_Costume ? this.contents.src&#xD;                : normalizeCanvas(this.contents).toDataURL('image/png'),&#xD;        this.embeddedData ? serializer.format(' embed="@"', this.embeddedData)&#xD;            : ''&#xD;    );&#xD;};&#xD;&#xD;Sound.prototype.toXML = function (serializer) {&#xD;    if(this.customData){&#xD;        return serializer.format(&#xD;            '&lt;sound name="@" customData="@" sound="@" ~/&gt;',&#xD;            this.name,&#xD;            this.customData,&#xD;            this.toDataURL()&#xD;        );&#xD;    }&#xD;    return serializer.format(&#xD;        '&lt;sound name="@" sound="@" ~/&gt;',&#xD;        this.name,&#xD;        this.toDataURL()&#xD;    );&#xD;};&#xD;&#xD;SnapSerializer.prototype.loadValue = function (model, object, silently) {&#xD;    // private&#xD;    var v, i, lst, items, el, center, image, name, audio, option, bool, origin,&#xD;    	wish, def,&#xD;        myself = this;&#xD;&#xD;    function record() {&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'id'&#xD;            )) {&#xD;            myself.objects[model.attributes.id] = v;&#xD;        }&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'mediaID'&#xD;            )) {&#xD;            myself.mediaDict[model.attributes.mediaID] = v;&#xD;        }&#xD;    }&#xD;&#xD;    switch (model.tag) {&#xD;    case 'ref':&#xD;        if (Object.prototype.hasOwnProperty.call(model.attributes, 'id')) {&#xD;            return this.objects[model.attributes.id];&#xD;        }&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'mediaID'&#xD;            )) {&#xD;            return this.mediaDict[model.attributes.mediaID];&#xD;        }&#xD;        throw new Error('expecting a reference id');&#xD;    case 'l':&#xD;        option = model.childNamed('option');&#xD;        if (option) {&#xD;            return [option.contents];&#xD;        }&#xD;        bool = model.childNamed('bool');&#xD;        if (bool) {&#xD;            return this.loadValue(bool);&#xD;        }&#xD;        wish = model.childNamed('wish');&#xD;        if (wish) {&#xD;            return this.loadValue(wish);&#xD;        }&#xD;        return model.contents;&#xD;    case 'bool':&#xD;        return model.contents === 'true';&#xD;    case 'list':&#xD;        if (model.attributes.hasOwnProperty('linked')) {&#xD;            if (model.attributes.struct === 'atomic') {&#xD;                v = Process.prototype.parseCSV(model.contents);&#xD;                v.becomeLinked();&#xD;                record();&#xD;                return v;&#xD;            }&#xD;            v = new List();&#xD;            v.isLinked = true;&#xD;            record();&#xD;            lst = v;&#xD;            items = model.childrenNamed('item');&#xD;            items.forEach((item, i) =&gt; {&#xD;                var value = item.children[0];&#xD;                if (!value) {&#xD;                    v.first = 0;&#xD;                } else {&#xD;                    v.first = this.loadValue(value, object);&#xD;                }&#xD;                var tail = model.childNamed('list') ||&#xD;                    model.childNamed('ref');&#xD;                if (tail) {&#xD;                    v.rest = this.loadValue(tail, object);&#xD;                } else {&#xD;                    if (i &lt; (items.length - 1)) {&#xD;                        v.rest = new List();&#xD;                        v = v.rest;&#xD;                        v.isLinked = true;&#xD;                    }&#xD;                }&#xD;            });&#xD;            return lst;&#xD;        }&#xD;        if (model.attributes.struct === 'atomic') {&#xD;            v = Process.prototype.parseCSV(model.contents);&#xD;            record();&#xD;            return v;&#xD;        }&#xD;        v = new List();&#xD;        record();&#xD;        v.contents = model.childrenNamed('item').map(item =&gt; {&#xD;            var value = item.children[0];&#xD;            if (!value) {&#xD;                return 0;&#xD;            }&#xD;            return this.loadValue(value, object);&#xD;        });&#xD;        return v;&#xD;    case 'sprite':&#xD;        v  = new SpriteMorph(this.scene.globalVariables);&#xD;        if (model.attributes.id) {&#xD;            this.objects[model.attributes.id] = v;&#xD;        }&#xD;        if (model.attributes.name) {&#xD;            v.name = model.attributes.name;&#xD;            this.scene.spritesDict[model.attributes.name] = v;&#xD;        }&#xD;        if (model.attributes.idx) {&#xD;            v.idx = +model.attributes.idx;&#xD;        }&#xD;        if (model.attributes.color) {&#xD;            v.color = this.loadColor(model.attributes.color);&#xD;            v.cachedColorDimensions = v.color[v.penColorModel]();&#xD;        }&#xD;        if (model.attributes.pen) {&#xD;            v.penPoint = model.attributes.pen;&#xD;        }&#xD;        if (model.attributes.volume) {&#xD;            v.volume = +model.attributes.volume;&#xD;        }&#xD;        if (model.attributes.pan) {&#xD;            v.pan = +model.attributes.pan;&#xD;        }&#xD;        if (!silently) {&#xD;            this.scene.stage.add(v);&#xD;        }&#xD;        v.scale = parseFloat(model.attributes.scale || '1');&#xD;        v.rotationStyle = parseFloat(&#xD;            model.attributes.rotation || '1'&#xD;        );&#xD;        v.isDraggable = model.attributes.draggable !== 'false';&#xD;        v.isVisible = model.attributes.hidden !== 'true';&#xD;        v.heading = parseFloat(model.attributes.heading) || 0;&#xD;        if (!silently) {&#xD;            v.gotoXY(+model.attributes.x || 0, +model.attributes.y || 0);&#xD;        }&#xD;        this.loadObject(v, model);&#xD;        v.fixLayout();&#xD;&#xD;        return v;&#xD;    case 'context':&#xD;        v = new Context(null);&#xD;        record();&#xD;        v.comment = model.childNamed('remark')?.contents;&#xD;        el = model.childNamed('origin');&#xD;        if (el) {&#xD;            el = el.childNamed('ref') || el.childNamed('sprite');&#xD;            if (el) {&#xD;                v.origin = this.loadValue(el);&#xD;            }&#xD;        }&#xD;        el = model.childNamed('receiver');&#xD;        if (el) {&#xD;            el = el.childNamed('ref') || el.childNamed('sprite');&#xD;            if (el) {&#xD;                v.receiver = this.loadValue(el);&#xD;            }&#xD;        }&#xD;        origin = v.origin || v.receiver || object; // for local blocks look up&#xD;        el = model.childNamed('script');&#xD;        if (el) {&#xD;            v.expression = this.loadScript(el, origin);&#xD;        } else {&#xD;            el = model.childNamed('block') ||&#xD;                model.childNamed('custom-block');&#xD;            if (el) {&#xD;                v.expression = this.loadBlock(el, null, origin);&#xD;            } else {&#xD;                el = model.childNamed('l');&#xD;                if (el) {&#xD;                    bool = el.childNamed('bool');&#xD;                    if (bool) {&#xD;                        v.expression = new BooleanSlotMorph(&#xD;                            this.loadValue(bool)&#xD;                        );&#xD;                    } else {&#xD;                        v.expression = new InputSlotMorph(el.contents);&#xD;                    }&#xD;                }&#xD;            }&#xD;        }&#xD;        if (v.expression instanceof BlockMorph) {&#xD;            // bind empty slots to implicit formal parameters&#xD;            i = 0;&#xD;            v.expression.allEmptySlots().forEach(slot =&gt; {&#xD;                i += 1;&#xD;                if (slot instanceof MultiArgMorph) {&#xD;                    slot.bindingID = ['arguments'];&#xD;                } else {&#xD;                    slot.bindingID = i;&#xD;                }&#xD;            });&#xD;            // and remember the number of detected empty slots&#xD;            v.emptySlots = i;&#xD;        }&#xD;        el = model.childNamed('inputs');&#xD;        if (el) {&#xD;            el.children.forEach(item =&gt; {&#xD;                if (item.tag === 'input') {&#xD;                    v.inputs.push(item.contents);&#xD;                }&#xD;            });&#xD;        }&#xD;        el = model.childNamed('variables');&#xD;        if (el) {&#xD;            this.loadVariables(v.variables, el, origin);&#xD;        }&#xD;        el = model.childNamed('context');&#xD;        if (el) {&#xD;            v.outerContext = this.loadValue(el, origin);&#xD;        }&#xD;        if (v.outerContext &amp;&amp; v.receiver &amp;&amp;&#xD;                !v.outerContext.variables.parentFrame) {&#xD;            v.outerContext.variables.parentFrame = v.receiver.variables;&#xD;        }&#xD;        return v;&#xD;    case 'costume':&#xD;        center = new Point();&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'center-x'&#xD;            )) {&#xD;            center.x = parseFloat(model.attributes['center-x']);&#xD;        }&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'center-y'&#xD;            )) {&#xD;            center.y = parseFloat(model.attributes['center-y']);&#xD;        }&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'name'&#xD;            )) {&#xD;            name = model.attributes.name;&#xD;        }&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'image'&#xD;            )) {&#xD;            image = new Image();&#xD;            if (model.attributes.image.indexOf('data:image/svg+xml') === 0&#xD;                    &amp;&amp; !MorphicPreferences.rasterizeSVGs) {&#xD;                v = new SVG_Costume(null, name, center);&#xD;                image.onload = function () {&#xD;                    v.contents = image;&#xD;                    v.version = +new Date();&#xD;                    if (typeof v.loaded === 'function') {&#xD;                        v.loaded();&#xD;                    } else {&#xD;                        v.loaded = true;&#xD;                    }&#xD;                };&#xD;            } else {&#xD;                v = new Costume(null, name, center);&#xD;                image.onload = function () {&#xD;                    var canvas = newCanvas(&#xD;                            new Point(image.width, image.height),&#xD;                            true // nonRetina&#xD;                        ),&#xD;                        context = canvas.getContext('2d');&#xD;                    context.drawImage(image, 0, 0);&#xD;                    v.contents = canvas;&#xD;                    v.version = +new Date();&#xD;                    if (Object.prototype.hasOwnProperty.call(&#xD;                        model.attributes,&#xD;                        'embed'&#xD;                    )) {&#xD;                        v.embeddedData = model.attributes.embed;&#xD;                    }&#xD;                    if (typeof v.loaded === 'function') {&#xD;                        v.loaded();&#xD;                    } else {&#xD;                        v.loaded = true;&#xD;                    }&#xD;                };&#xD;            }&#xD;            image.src = model.attributes.image;&#xD;            if(model.attributes["customData"]){&#xD;                v.customData = model.attributes["customData"];&#xD;            }&#xD;        }&#xD;        record();&#xD;        return v;&#xD;    case 'sound':&#xD;        audio = new Audio();&#xD;        v = new Sound(audio, model.attributes.name);&#xD;        audio.oncanplaythrough = () =&gt; v.loaded = true;&#xD;        audio.src = model.attributes.sound;&#xD;        if (Object.prototype.hasOwnProperty.call(&#xD;                model.attributes,&#xD;                'mediaID'&#xD;            )) {&#xD;            this.mediaDict[model.attributes.mediaID] = v;&#xD;        }&#xD;        if(model.attributes["customData"]){&#xD;            v.customData = model.attributes["customData"];&#xD;        }&#xD;        record();&#xD;        return v;&#xD;    case 'wish':&#xD;    	def = new CustomBlockDefinition(model.attributes.s);&#xD;     	def.type = model.attributes.type;&#xD;      	def.category = model.attributes.category;&#xD;       	def.storedSemanticSpec = model.attributes.s;&#xD;        def.updateTranslations(model.contents);&#xD;        return def.blockInstance(true); // include translations&#xD;    }&#xD;    return undefined;&#xD;};&#xD;&#xD;SnapSerializer.prototype.loadVariables = function (varFrame, element, object) {&#xD;    // private&#xD;    element.children.forEach(child =&gt; {&#xD;        var v, value;&#xD;        if (child.tag !== 'variable') {&#xD;            return;&#xD;        }&#xD;        value = child.children[0];&#xD;        v = new Variable();&#xD;        if(child.attributes["customData"]){&#xD;            v.customData = child.attributes["customData"];&#xD;        }&#xD;        v.isTransient = (child.attributes.transient === 'true');&#xD;        v.isHidden = (child.attributes.hidden === 'true');&#xD;        v.value = (v.isTransient || !value ) ? 0&#xD;                : this.loadValue(value, object);&#xD;        varFrame.vars[child.attributes.name] = v;&#xD;    });&#xD;};&#xD;&#xD;VariableFrame.prototype.toXML = function (serializer) {&#xD;    return Object.keys(this.vars).reduce((vars, v) =&gt; {&#xD;        var val = this.vars[v].value,&#xD;            transient = this.vars[v].isTransient,&#xD;            hidden = this.vars[v].isHidden,&#xD;            dta&#xD;            customData = this.vars[v]["customData"];&#xD;&#xD;        if (transient || val === undefined || val === null) {&#xD;            if(customData){&#xD;                dta = serializer.format(&#xD;                    '&lt;variable name="@"' +&#xD;                        (transient ? ' transient="true"' : '') +&#xD;                        (hidden ? ' hidden="true"' : '') +&#xD;                        (customData ? ' customData="@"' : '') +&#xD;                        '/&gt;',&#xD;                    v,&#xD;                    customData&#xD;                );&#xD;            } else {&#xD;                dta = serializer.format(&#xD;                    '&lt;variable name="@"' +&#xD;                        (transient ? ' transient="true"' : '') +&#xD;                        (hidden ? ' hidden="true"' : '') +&#xD;                        '/&gt;',&#xD;                    v&#xD;                );&#xD;            }&#xD;        } else {&#xD;            if(customData){&#xD;                dta = serializer.format(&#xD;                    '&lt;variable name="@"' +&#xD;                        (transient ? ' transient="true"' : '') +&#xD;                        (hidden ? ' hidden="true"' : '') +&#xD;                        ' customData="@"'+&#xD;                        '&gt;%&lt;/variable&gt;',&#xD;                    v,&#xD;                    customData,&#xD;                    typeof val === 'object' ?&#xD;                            (isSnapObject(val) ? ''&#xD;                                    : serializer.store(val))&#xD;                                    : typeof val === 'boolean' ?&#xD;                                            serializer.format(&#xD;                                                '&lt;bool&gt;$&lt;/bool&gt;', val&#xD;                                            )&#xD;                                            : serializer.format('&lt;l&gt;$&lt;/l&gt;', val)&#xD;                );&#xD;            } else {&#xD;                dta = serializer.format(&#xD;                    '&lt;variable name="@"' +&#xD;                        (transient ? ' transient="true"' : '') +&#xD;                        (hidden ? ' hidden="true"' : '') +&#xD;                        '&gt;%&lt;/variable&gt;',&#xD;                    v,&#xD;                    typeof val === 'object' ?&#xD;                            (isSnapObject(val) ? ''&#xD;                                    : serializer.store(val))&#xD;                                    : typeof val === 'boolean' ?&#xD;                                            serializer.format(&#xD;                                                '&lt;bool&gt;$&lt;/bool&gt;', val&#xD;                                            )&#xD;                                            : serializer.format('&lt;l&gt;$&lt;/l&gt;', val)&#xD;                );&#xD;            }&#xD;        }&#xD;        return vars + dta;&#xD;    }, '');&#xD;};&#xD;&#xD;Project.prototype.toXML = function (serializer) {&#xD;    var thumbdata;&#xD;&#xD;    // thumb data catch cross-origin tainting exception when using SVG costumes&#xD;    try {&#xD;        thumbdata = this.thumbnail.toDataURL('image/png');&#xD;    } catch (error) {&#xD;        thumbdata = null;&#xD;    }&#xD;&#xD;    if(window.projectCustomData){&#xD;        return serializer.format(&#xD;            '&lt;project name="@" app="@" version="@" customData="@"&gt;' +&#xD;                '&lt;notes&gt;$&lt;/notes&gt;' +&#xD;                '&lt;thumbnail&gt;$&lt;/thumbnail&gt;' +&#xD;                '&lt;scenes select="@"&gt;%&lt;/scenes&gt;' +&#xD;                '&lt;/project&gt;',&#xD;            this.name || localize('Untitled'),&#xD;            serializer.app,&#xD;            serializer.version,&#xD;            window.projectCustomData,&#xD;            this.notes || '',&#xD;            thumbdata,&#xD;            this.scenes.asArray().indexOf(&#xD;                this.currentScene) + 1,&#xD;            serializer.store(this.scenes.itemsArray())&#xD;        );&#xD;    }&#xD;&#xD;    return serializer.format(&#xD;        '&lt;project name="@" app="@" version="@"&gt;' +&#xD;            '&lt;notes&gt;$&lt;/notes&gt;' +&#xD;            '&lt;thumbnail&gt;$&lt;/thumbnail&gt;' +&#xD;            '&lt;scenes select="@"&gt;%&lt;/scenes&gt;' +&#xD;            '&lt;/project&gt;',&#xD;        this.name || localize('Untitled'),&#xD;        serializer.app,&#xD;        serializer.version,&#xD;        this.notes || '',&#xD;        thumbdata,&#xD;        this.scenes.asArray().indexOf(&#xD;            this.currentScene) + 1,&#xD;        serializer.store(this.scenes.itemsArray())&#xD;    );&#xD;};&#xD;&#xD;SnapSerializer.prototype.loadProjectModel = function (xmlNode, ide, remixID) {&#xD;    // public - answer a new Project represented by the given XML top node&#xD;    // show a warning if the origin apps differ&#xD;&#xD;    var appInfo = xmlNode.attributes.app,&#xD;        app = appInfo ? appInfo.split(' ')[0] : null,&#xD;        appVersion = appInfo ? parseFloat(appInfo.split(' ')[1]) || 0 : 0,&#xD;        scenesModel = xmlNode.childNamed('scenes'),&#xD;        project = new Project();&#xD;&#xD;    if (ide &amp;&amp; app &amp;&amp; app !== this.app.split(' ')[0]) {&#xD;        ide.inform(&#xD;            app + ' Project',&#xD;            'This project has been created by a different app:\n\n' +&#xD;                app +&#xD;                '\n\nand may be incompatible or fail to load here.'&#xD;        ).nag = true;&#xD;    }&#xD;    if (scenesModel) {&#xD;        if (scenesModel.attributes.select) {&#xD;            project.sceneIdx = +scenesModel.attributes.select;&#xD;        }&#xD;        scenesModel.childrenNamed('scene').forEach(model =&gt; {&#xD;            ide.scene.captureGlobalSettings();&#xD;            project.scenes.add(this.loadScene(model, appVersion));&#xD;            ide.scene.applyGlobalSettings();&#xD;        });&#xD;    } else {&#xD;        project.scenes.add(this.loadScene(xmlNode, appVersion, remixID));&#xD;    }&#xD;    if(xmlNode.attributes["customData"]){&#xD;        //since project is not maintained as object from deserialize to serialize, &#xD;        //and project only is named once, add customData to window...&#xD;        window.projectCustomData = xmlNode.attributes["customData"];&#xD;    }&#xD;    return project.initialize();&#xD;};&#xD;&#xD;loadFile();&#xD;world.children[0].setBlocksScale(1);&#xD;&#xD;async function loadFile () {&#xD;  var res = await fetch("{{url}}");&#xD;  var xml = await res.text();&#xD;&#xD;  // fix xml encoding for umlaute&#xD;  let charMap = {&#xD;    "&amp;#252;": "ü",&#xD;    "&amp;#246;": "ö",&#xD;    "&amp;#228;": "ä",&#xD;    "&amp;#220;": "Ü",&#xD;    "&amp;#214;": "Ö",&#xD;    "&amp;#196;": "Ä",&#xD;    "&amp;#223;": "ß",&#xD;    "&amp;#8364;": "€"&#xD;  };&#xD;  for(let entity in charMap) {&#xD;    let char = charMap[entity];&#xD;    xml= xml.replace(new RegExp(entity, 'g'), char);&#xD;  }&#xD;  var ide = window.world.root().children[0];&#xD;  ide.loadProjectXML(xml)&#xD;}</l>
                            </block>
                            <list></list>
                        </block>
                    </script>
                </block-definition>
            </blocks>
            <stage name="Stage" width="480" height="360" costume="0" color="255,255,255,1" tempo="60" threadsafe="false" penlog="false" volume="100" pan="0" lines="round" ternary="false" hyperops="true" codify="false" inheritance="true" sublistIDs="false" id="15">
                <pentrails>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAFoCAYAAACPNyggAAAOhUlEQVR4Xu3VwQkAAAjEMN1/abewn7jAQRC64wgQIECAAIF3gX1fNEiAAAECBAiMAHsCAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQIHLFxAWmhEwHPAAAAAElFTkSuQmCC</pentrails>
                <costumes>
                    <list struct="atomic" id="16"></list>
                </costumes>
                <sounds>
                    <list struct="atomic" id="17"></list>
                </sounds>
                <variables></variables>
                <blocks></blocks>
                <scripts></scripts>
                <sprites select="1">
                    <sprite name="Sprite" idx="1" x="0" y="0" heading="90" scale="1" volume="100" pan="0" rotation="1" draggable="true" costume="0" color="80,80,80,1" pen="tip" id="22">
                        <costumes>
                            <list struct="atomic" id="23"></list>
                        </costumes>
                        <sounds>
                            <list struct="atomic" id="24"></list>
                        </sounds>
                        <blocks></blocks>
                        <variables></variables>
                        <scripts>
                            <script x="20" y="20">
                                <custom-block s="Activate JS and Import Data">
                                    <comment w="90" collapsed="false">Activate JS in the top left corner and press this button to import your project file.</comment>
                                </custom-block>
                            </script>
                        </scripts>
                    </sprite>
                </sprites>
            </stage>
            <variables></variables>
        </scene>
    </scenes>
</project>